#!/usr/bin/env python3
"""
Solar2D HTML5 Build - Post-Build Patcher (WASM builds)
1. Removes the blur callback registration to prevent HTML5 builds from freezing when user clicks outside of the app.
2. Removes the alert() from printErr to prevent blocking popups on non-fatal WASM errors.
3. Deletes index-debug.html and index-nosplash.html (unused in production).
"""

import zipfile
import os
import sys
import shutil
import re
from pathlib import Path

line_length = 60

def remove_blur_callback(js_content):
    """
    Remove the blur callback registration from _emscripten_set_blur_callback_on_thread.
    """
    pattern = r'(function _emscripten_set_blur_callback_on_thread\([^)]*\)\{)registerFocusEventCallback\([^)]*\);(return 0\})'

    modified_content = re.sub(pattern, r'\1\2', js_content)

    if modified_content != js_content:
        print("Successfully removed blur callback registration")
        return modified_content, True

    print("Warning: Could not find the expected function pattern.")
    print("This file may already be modified or have a different structure.")
    return js_content, False


def process_bin_file(bin_path):
    """
    Process the .bin file (zip archive):
    1. Extract it
    2. Modify the .js file (same name as .bin)
    3. Re-zip it
    """
    bin_path = Path(bin_path)

    if not bin_path.exists():
        print(f"Error: File '{bin_path}' not found!")
        return False

    print(f"Processing: {bin_path}")

    temp_dir = bin_path.parent / f"{bin_path.stem}_temp"

    try:
        # .bin is a zip archive containing the JS app and WASM module
        print("Extracting files...")
        with zipfile.ZipFile(bin_path, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)

        # Find the .js file (same name as .bin file)
        js_filename = bin_path.stem + ".js"
        js_file = temp_dir / js_filename

        if not js_file.exists():
            print(f"Error: {js_filename} not found in the archive!")
            print("Looking for any .js files in the archive...")
            js_files = list(temp_dir.glob("*.js"))
            if js_files:
                print(f"Found: {[f.name for f in js_files]}")
                print(f"Expected: {js_filename}")
            return False

        print(f"Found: {js_file.name}")

        with open(js_file, 'r', encoding='utf-8') as f:
            js_content = f.read()

        print("Modifying blur callback function...")
        modified_content, was_modified = remove_blur_callback(js_content)

        if not was_modified:
            print("No modifications made. The file may already be modified.")
            user_input = input("Continue anyway? (y/n): ").strip().lower()
            if user_input != 'y':
                return False

        with open(js_file, 'w', encoding='utf-8') as f:
            f.write(modified_content)

        # Repack the archive with the patched JS file
        print("Re-creating archive...")
        with zipfile.ZipFile(bin_path, 'w', zipfile.ZIP_DEFLATED) as zip_ref:
            for root, dirs, files in os.walk(temp_dir):
                for file in files:
                    file_path = Path(root) / file
                    arcname = file_path.relative_to(temp_dir)
                    zip_ref.write(file_path, arcname)

        print(f"Successfully processed {bin_path.name}")
        return True

    except Exception as e:
        print(f"Error: {e}")
        return False

    finally:
        if temp_dir.exists():
            shutil.rmtree(temp_dir)
            print("Cleaned up temporary files")


def patch_index_html(bin_dir):
    """
    Patch bin/index.html to remove alert() from printErr.
    The Solar2D-generated printErr calls alert() for any error containing 'ERROR',
    which blocks the UI thread and can cause cascading WASM crashes.
    """
    index_path = bin_dir / "index.html"

    if not index_path.exists():
        print(f"Warning: {index_path} not found, skipping printErr patch")
        return False

    with open(index_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Remove the alert() call from printErr, keeping the console.error
    pattern = r'''if\(\s*typeof\(text\)\s*===\s*"string"\s*&&\s*text\.toUpperCase\(\)\.indexOf\("ERROR"\)\s*>=\s*0\)\s*alert\(text\);'''

    modified = re.sub(pattern, '// alert removed: blocking alert() on errors causes WASM crashes and freezes the UI', content)

    if modified != content:
        with open(index_path, 'w', encoding='utf-8') as f:
            f.write(modified)
        print("Removed alert() from printErr in index.html")
        return True
    else:
        print("Note: printErr alert pattern not found in index.html (may already be patched)")
        return False


def delete_unused_html(bin_dir):
    """
    Delete index-debug.html and index-nosplash.html from the bin directory.
    These are generated by Solar2D but not used in production.
    """
    files_to_delete = ["index-debug.html", "index-nosplash.html"]
    deleted = []

    for filename in files_to_delete:
        file_path = bin_dir / filename
        if file_path.exists():
            file_path.unlink()
            print(f"Deleted {filename}")
            deleted.append(filename)

    if not deleted:
        print("Note: No unused HTML files found to delete")

    return len(deleted) > 0


def clean_path(raw_path):
    """
    Clean up a path string from terminal input.
    Handles VS Code/PowerShell drag-and-drop artifacts and surrounding quotes.
    """
    path = raw_path.strip()

    # VS Code adds "& '" at the beginning when drag-dropping
    if path.startswith("& '") or path.startswith('& "'):
        path = path[2:].strip()

    # Remove surrounding quotes (from drag and drop)
    path = path.strip('"').strip("'")

    return path


def find_bin_in_dir(directory):
    """
    Find a single .bin file in a directory.
    Returns the path if exactly one .bin file is found, otherwise None.
    """
    directory = Path(directory)
    if not directory.is_dir():
        return None

    bin_files = list(directory.glob("*.bin"))

    if len(bin_files) == 1:
        return bin_files[0]
    elif len(bin_files) > 1:
        print(f"Error: Multiple .bin files found in '{directory}':")
        for f in bin_files:
            print(f"  - {f.name}")
        print("Please specify which file to process.")

    return None


def resolve_bin_path(user_path):
    """
    Resolve user input to a .bin file path.
    Accepts a direct .bin file path or a folder containing a .bin file.
    """
    path = Path(user_path)

    if path.is_file() and path.suffix == '.bin':
        return path

    if path.is_dir():
        result = find_bin_in_dir(path)
        if result:
            return result
        print(f"Error: No .bin file found in '{path}'")
        return None

    if not path.exists():
        print(f"Error: '{path}' does not exist!")
        return None

    print(f"Error: '{path}' is not a .bin file or directory")
    return None


def auto_detect_bin():
    """
    Auto-detect .bin file in the script's directory or its 'bin' subdirectory.
    """
    script_dir = Path(__file__).parent

    result = find_bin_in_dir(script_dir)
    if result:
        return result

    bin_dir = script_dir / "bin"
    result = find_bin_in_dir(bin_dir)
    if result:
        return result

    print(f"Error: No .bin file found in '{script_dir}' or '{bin_dir}'")
    return None


def main():
    print("=" * line_length)
    print("Solar2D HTML5 - Post-Build Patcher (WASM)")
    print("Patches blur callback + printErr alert + cleanup")
    print("=" * line_length)
    print()

    bin_path = None

    if len(sys.argv) > 1:
        bin_path = resolve_bin_path(clean_path(sys.argv[1]))
    else:
        print("Provide the path to your .bin file or its folder by:")
        print("  - Typing or pasting a path to the .bin file or its folder")
        print("  - Dragging and dropping the file or its folder into this window")
        print("  - Pressing Enter to auto-detect the file in the current folder")
        print()

        try:
            user_input = input("> ").strip()
        except (KeyboardInterrupt, EOFError):
            print("\nExiting...")
            return

        if user_input:
            bin_path = resolve_bin_path(clean_path(user_input))
        else:
            print("Auto-detecting .bin file...")
            bin_path = auto_detect_bin()

    if not bin_path:
        input("\nPress Enter to exit...")
        return

    print(f"Found: {bin_path}")
    print()

    bin_dir = bin_path.parent
    bin_success = process_bin_file(bin_path)

    print()
    print("-" * line_length)
    print("Patching index.html...")
    html_success = patch_index_html(bin_dir)

    print()
    print("-" * line_length)
    print("Cleaning up unused HTML files...")
    delete_unused_html(bin_dir)

    print()
    print("=" * line_length)

    if bin_success and html_success:
        print("SUCCESS! Your HTML5 build has been modified.")
        print("- Blur callback removed (no freeze on click outside)")
        print("- printErr alert removed (no blocking popups on errors)")
        print("- Unused HTML files cleaned up")
    elif bin_success:
        print("Blur callback removed successfully.")
        print("Note: index.html printErr patch was skipped (see above).")
    else:
        print("Process completed with warnings or errors.")
        print("Please check the messages above.")

    print("=" * line_length)
    input("\nPress Enter to exit...")


if __name__ == "__main__":
    main()